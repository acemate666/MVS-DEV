# 反弹后网球第二段轨迹预测与在线校正（工程技术报告，v1.1）

> 本文档面向工程落地：在缺少自旋/接触状态观测的现实条件下，用“候选走廊（prior）+ 少点强校正（posterior）”实现**稳定不炸**并在 $N\le 5$ 个反弹后点出现时**快速收敛**。

## 阅读指南（建议先看这些）

* 想最短路径实现：先看 2.3（输出）→ 4.2（候选）→ 5.2/5.3（少点校正与融合）。
* 想先排坑：直接看 2.4.4（分段契约）与 9.2（在线排障清单）。
* 想稳住拦截/落点：优先实现 4.3.2（按平面输出）与 9.3（落点指标）。

## 快速摘要（1 分钟版本）

**核心假设**（为了 RK 芯片算力与稳定性做出的取舍）：

1. 反弹后短时段飞行动力学主干只用重力（解析计算）；水平面的系统性偏差优先交给第二阶段的等效低维项（例如 $a_{xz}$）在 $N\le 5$ 下做少点校正吸收。
2. 反弹事件 $(t_b,p_b,v^-)$ 通常不可观测，必须由反弹前窗口稳健估计；尤其要避免 post 点污染导致 $t_b$ 漂移。
3. 第一阶段不输出“唯一真值”，而输出**少量候选**与**走廊**；第二阶段在 $N\le 5$ 下对每个候选做带先验的**递推正则最小二乘（信息形式）**，再用后验代价更新权重，避免早锁错。

**说明（drag/Magnus）**：由于自旋在工程上几乎不可观测/不可稳定估计，基于自旋的 Magnus 项在线无法可靠标定；阻力项也容易与时间基准误差、观测噪声、接触状态不确定性互相混淆并引入新的数值敏感点。因此本文档的工程方案**明确不包含** drag/Magnus 的在线建模与数值积分设计：空气效应带来的主要偏差由（1）第一阶段候选/走廊覆盖，（2）第二阶段的等效低维项（如 $a_{xz}$）在 $N\le 5$ 下少点校正吸收。

**计算预算直觉**：

* 候选数 $M\in\{9,27\}$（可配）。
* 第二阶段每次更新解一个 $3\times 3$ 或 $5\times 5$ 的小线性系统，做 $M$ 次，量级固定且可控。
* 推荐默认输出“按平面”的走廊，避免对密采样轨迹的依赖。

---

## 0. 文档信息

* 文档目标：给出可落地的两阶段算法与接口，满足“第一阶段避免灾难性偏差 + 第二阶段（$N\le 5$）快速收敛”的工程需求。
* 适用场景：网球机器人拦截/落点预测等需要反弹后短时轨迹预测的系统。
* 非目标：在缺少自旋/接触状态观测的前提下，我们不承诺“只看反弹前这一段，就能 100% 唯一确定反弹后轨迹真值”。第一阶段依然要尽可能预测得准，但必须同时输出不确定性（候选/走廊），用于风险控制，并让第二阶段用 few-shot 点快速校正与收敛。

### 0.1 术语与缩写

* 第一阶段 / prior：仅使用反弹前信息生成第二段的名义预测与不确定性走廊。
* 第二阶段 / posterior：利用反弹后少量观测点对第二段进行快速校正。
* 走廊（corridor）：对未来位置/到达时间的不确定性集合表示（协方差椭圆、分位数包络、混合分量等）。
* 候选（candidate）：由不同反弹参数组合生成的第二段轨迹假设。
* 递推的正则最小二乘（信息形式，推荐默认）：维护法方程（信息矩阵/信息向量）并递推更新的一套统一解算器；既可每来一个点就更新并可立即求解输出，也可把 $N$ 个点依次更新后再统一求解一次。
* MAP：最大后验（最大权重）候选。

### 0.2 符号与约定（减少歧义）

* 事件量：$t_b$（反弹时刻）、$p_b$（反弹位置，球心）、$v^-$（反弹前速度）、$v^+$（反弹后初速度）。
* 相对时间：$\tau=t-t_b$。文中默认所有“第二段模型”都用 $\tau$ 表达。
* 触地球心高度：$y_c=y_{\text{ground}}+r+b_y$。反弹事件求根与落点定义都应使用 $y_c$，不要硬编码 $0$。
* 地面基：$\hat{n}$ 为地面法向（朝上），$(\hat{t}_1,\hat{t}_2)$ 为切平面正交基。
  * 平地默认可取 $\hat{n}=[0,1,0]^\top$、$\hat{t}_1=[1,0,0]^\top$、$\hat{t}_2=[0,0,1]^\top$。
* 本文的“走廊 corridor”是面向决策的风险边界表示。**工程默认推荐**：输出“按拦截平面”的分位数包络（例如 5/95），实现最简单且对多峰最安全；**可选增强**：输出 top-K 混合分量（weight/mean/cov）。不建议默认仅用单高斯（均值+协方差）作为唯一表示（多峰时易误导）。

## 1. 背景与核心需求

### 1.1 现象与痛点

反弹后第二段轨迹受旋转、摩擦状态（滑移/粘着）、场地材料与球况影响显著。仅依赖第一段信息时，这些因素在一定程度上不可辨识，因此若第一阶段只输出“单一曲线”，容易出现大偏差。

另一个更“工程现实”的问题是：**落地点/反弹点往往不可观测**。

* 反弹附近经常因为遮挡、运动模糊、相机视角或检测器的置信度门限而缺帧。
* 许多数据里所谓的 “bounce_index” 更像“最低可见点”，并不等价于真实触地时刻。
* 因此在绝大多数场景下，系统必须把 $(t_b,p_b)$ 视为 **需要估计的隐变量**，而不是可直接读取的观测。

这会引出一个非常关键的工程结论：

* 若 $t_b$ 估计发生漂移，则第二段相对时间 $\tau=t-t_b$ 会被放大或缩小，从而把本来小的模型误差放大成“落点离谱”的灾难性偏差。
* 因而在做任何连续化优化之前，应优先保证 $t_b$ 的时间基准稳定（见 5.5）。

### 1.2 需求拆解（分两阶段验收）

第一阶段（无第二段点）：

* 输出：名义预测轨迹 + 不确定性走廊。
* 验收口径：

  * 名义预测不出现量级失配（避免米级灾难性偏差）。
  * 走廊覆盖率高（例如 90%/95%），且走廊宽度尽可能小（可量化）。

第二阶段（出现 $N\le 5$ 个第二段点）：

* 输出：快速校正后的第二段轨迹/关键点（拦截点、到达时间等）。
* 验收口径：在任务相关拦截平面/时间窗内达到目标误差，并体现“随点数增加快速收敛”。

工程约束：

* 计算量基本固定，便于嵌入式实时运行（候选数、输出时刻数、解算维度可控）。
* 可解释、可调参、可在线收敛。
* 对异常点/噪声鲁棒，避免“早期锁错分支导致自洽错误”。

## 2. 输入输出与坐标约定

### 2.1 坐标与单位

* 建议使用统一世界坐标系（单位：m、s）。
* 坐标轴约定（以 `curve2.py` 为准）：

  * $x$ 轴向右为正
  * $z$ 轴向前为正
  * $y$ 轴向上为正
* 重力方向：$\mathbf{g}=[0,-g,0]^\top$（沿 $-y$ 方向）。
* 地面法向记为 $\hat{n}$，切平面方向为 $(\hat{t}_1,\hat{t}_2)$。

### 2.2 输入（最小集合）

第一阶段输入（来自“第一段状态估计模块”，见 2.4）：

* 反弹时刻 $t_b$（通常不可直接观测，应由第一段点估计得到）。
* 反弹位置 $p_b\in\mathbb{R}^3$（球心位置；同样通常不可直接观测，需由第一段模型外推得到）。
* 反弹前速度 $v^-\in\mathbb{R}^3$（由第一段拟合/滤波得到）。
* （建议）$(p_b, v^-)$ 的协方差或至少噪声尺度估计（用于候选权重与走廊宽度）。
* （强烈建议，哪怕先做成可空字段）场地/区域 ID、触地点区域索引、球类型等元信息：用于第 6 章的数据驱动先验（分桶/冷启动），在新场地上线时往往比增加复杂动力学更“立竿见影”。

补充说明：

* 当反弹点不可见时，第一段模块的输出不应被理解为“精确真值”，而是带不确定度的估计。
* 若上游只能给出“近似反弹窗口”（例如最后一帧可见下降点之后的某个时间范围），也可以将其作为 $t_b$ 的先验/约束（例如网格搜索窗口与先验方差，见 5.5）。

第二阶段额外输入：

* 反弹后观测点 $\{(t_i,p_i)\}_{i=1}^N$，其中 $1\le N\le 5$。

#### 2.2.1 可选增强输入：多相机 2D 观测（像素域闭环 / 重投影一致性）

背景与动机（工程事实）：

* 相机的“原始测量”是每相机像素坐标 $(u,v)$，而 3D 点 $p_i$ 是由多个相机的 2D 观测三角化得到的派生量。
* 在远距离、视差变小、遮挡/模糊等退化条件下，3D 点的误差会强非线性放大，且误差往往各向异性（深度方向显著更差）。
* 若只保留 3D 点而丢弃 2D 观测，则会丢失“哪个相机在该帧更可信”“该帧误差各向异性”“可诊断的一致性指标”等关键信息。

一个常用的“误差放大量级”直觉（用于解释而非作为实现假设）：在 rectified stereo 近似下，视差 $d=u_L-u_R$，深度

$$
Z \approx \frac{f\,b}{d},\qquad
\sigma_Z \approx \frac{Z^2}{f\,b}\,\sigma_d.
$$

因此当球更远（$Z$ 变大、$d$ 变小）时，深度噪声会快速变大；这也是“3D 点域看起来抖，但像素域仍可用”的主要原因之一。

因此，工程上强烈建议：

* **在接口上允许 2D 观测可空，但不要阻止其传入**。
* 当存在 2D 观测且相机投影模型可用时，优先用像素域一致性做闭环精修，以提高精度上限并增强可诊断性。

可选输入定义：

* 对每个 3D 观测点（每帧），允许携带一个映射：

  * `obs_2d_by_camera`：key 为相机标识（例如 `cam0`），value 为该相机下该帧球心像素观测与协方差。

* 每条 2D 观测建议至少包含：

  * 像素坐标 $z_{ij}=(u_{ij},v_{ij})$（单位 px）
  * 像素噪声协方差 $\Sigma_{ij}\in\mathbb{R}^{2\times 2}$（单位 px$^2$）
  * 可选的质量分/来源字段（用于日志与调参）

##### 2.2.1.1 与上游融合输出协议对齐（`protocols/mvs_ball_localization_types.py`）

本小节的目的：把“2D 观测怎么传进来、字段口径是什么、哪些信息仍需系统注入”写成可执行契约，避免像素域闭环在工程联调时被误用。

上游融合定位输出（类型协议见 `protocols/mvs_ball_localization_types.py`）可以天然承载本节所需的 2D 观测数据：

* 一帧记录：`FusedLocalizationRecord`
  * `created_at`：记录写出时间（**不建议**当作物理曝光时间/拟合时间戳）。
  * 其它 meta：协议允许透传（例如 `frame_id`、`capture_t_abs`、`t_abs` 等）。
* 单球输出：`FusedBall`
  * `ball_3d_world`：三角化得到的 3D 点（单位 m）。
  * `obs_2d_by_camera`（可选）：每相机 2D 观测与协方差（本节输入）。
    * 每个相机条目为 `Obs2DWithCov`：`uv`、`cov_uv`、`sigma_px`、`cov_source`（单位口径见该文件头注释）。
  * `used_cameras` / `num_views` / `quality` / `median_reproj_error_px` 等：可用于日志与门控（见 5.6 与 9.2）。

强烈建议上游透传/明确以下“口径字段”，否则像素域误差会被时间错位/坐标口径不一致污染：

* **时间戳口径（必须明确）**：
  * 推荐：在 record 级别提供 `capture_t_abs`（或等价字段）作为该帧的物理采集时间。
  * 允许：若不同相机曝光不同步，需提供相机级时间戳（例如 `capture_t_abs_by_camera`），并在像素域闭环里使用对应相机的时间。
  * 禁止默认：把 `created_at` 当作曝光时间使用（它通常是处理/写盘时间）。
* **相机标识一致性（必须可回放复现）**：`obs_2d_by_camera` 的 key（例如 `cam0`）必须与标定/投影模型中的相机 ID 完全一致，并保证同一回放序列下稳定不变。

##### 2.2.1.2 必须由系统注入的信息（非 schema 字段）

即使上游提供了 `obs_2d_by_camera`，像素域闭环要“可用且可诊断”，仍需要系统在运行时注入以下信息（这些不应塞进 `FusedBall` 里强行 JSON 化）：

* **相机投影模型**：对每个相机提供 $\pi_j(\cdot)$（世界系 3D $\to$ 像素系 $u,v$）。至少要覆盖：
  * 内参/畸变与外参（或等价的统一投影函数）。
  * 明确 $z_{ij}$ 的坐标口径：是“原始像素（含畸变）”还是“去畸变像素/归一化坐标”。
* **世界坐标系对齐**：$\pi_j$ 所用世界系必须与 `ball_3d_world`、以及本算法的动力学坐标系一致。
* **数据关联可追溯**：当上游提供 `detection_index`（或等价索引）时，建议同时保证可回放到原始 detection（用于排查错关联）。

契约化回退规则（必须保持历史行为）：

* 若缺少相机投影模型，或 `obs_2d_by_camera` 为空：像素域闭环一律禁用，自动回退到 3D 点域 stage2。
* 若仅部分相机/部分帧有 2D：允许部分使用，但必须满足“最小可用观测数”门限（例如每帧至少 $K\ge 2$ 个相机通过门控才更新）。

说明：下文继续给出更细粒度的“算法层”约定与建议（相机投影口径、门控、噪声模型等），与本节契约保持一致。

相机投影模型（必须由上游提供/注入）：

* 记 $\pi_j(\cdot)$ 为第 $j$ 个相机的投影函数：世界系 3D 点 $P\in\mathbb{R}^3$ 投影到像素坐标 $(u,v)$。
* 投影口径必须一致（是否去畸变、外参坐标系定义等），否则重投影误差没有意义。

回退与兼容性约定（必须写成契约）：

* 当 `obs_2d_by_camera` 为空（None 或空映射）或上游未注入相机投影模型时：

  * 算法必须自动回退到纯 3D 点域的 stage2（保持历史行为与算力预算）。

* 2D 观测缺失允许“按相机/按帧部分缺失”（只要还有足够的 3D 点/或足够的像素观测可用）。

前置条件（必须写清，否则“像素域误差”会被误用）：

* 相机内参/外参与畸变口径必须与投影函数一致：

  * 若 $z_{ij}=(u,v)$ 是“已去畸变/归一化坐标”，则 $\pi_j(\cdot)$ 必须输出同口径坐标；
  * 若 $z_{ij}$ 是“原始像素坐标（含畸变）”，则 $\pi_j(\cdot)$ 必须包含同样的畸变模型。

* 时间同步口径必须明确：$z_{ij}$ 对应的曝光时刻/时间戳必须与 3D 点 $p_i$ 的时间 $t_i$ 对齐，否则闭环会把“时间错位”当成动力学误差。
* 数据关联必须可追溯：每个 $z_{ij}$ 必须能回放复现（同一输入序列与参数下，关联结果唯一）。错关联是像素域闭环最常见的失败源之一。

2D 噪声模型与协方差口径（建议默认与可选增强）：

* 基础默认（最小可落地）：

  * 若上游无法给出像素协方差，建议先使用各向同性模型 $\Sigma_{ij}=\sigma_{px}^2 I_2$。
  * $\sigma_{px}$ 可由检测器质量粗分档给经验值（例如：清晰 0.5px，模糊 1.5px），并在离线标定后替换为更可信的映射。

* 可选增强（更严谨，推荐逐步上线）：

  * 允许 $\Sigma_{ij}$ 为各向异性（例如检测框的长短轴带来不同方向不确定度）。
  * 若检测器能输出置信度/模糊度/目标尺寸，可用它们构造 $\Sigma_{ij}$ 的尺度（但必须在离线数据上验证单调性与饱和区间，避免置信度未标定导致反向加权）。

2D 门控与坏点策略（建议写成“规则”，不要拍脑袋）：

* 单观测门控：若 $\|r_{ij}\|$ 明显超过阈值（例如 $>\tau_{px}$），优先对该 (帧,相机) 观测降权或剔除，而不是整帧丢弃。
* 帧级门控：建议使用“至少 $K$ 个相机通过门控才更新”的规则（例如 $K\ge 2$），否则仅预测/仅输出走廊。
* 反弹附近脏帧：bounce 前后 1–2 帧经常出现遮挡/触地形变/反光/模糊，建议默认降权或剔除，以避免把最脏的约束喂给闭环。


### 2.3 输出（接口草案）

第一阶段输出：

* `nominal_trajectory`：名义第二段轨迹（采样点序列或参数化）。
* `corridor`：走廊输出，支持：

  * `corridor_by_time`：在时刻集合 $\{t_k\}$ 输出 $(x,z)$ 的均值与 $2\times 2$ 协方差（或分位数包络/混合分量）；
  * `corridor_on_plane`：在拦截平面（例如 $y=y_0$）输出反弹后的**下降穿越**点 $(x,z)$ 的均值/协方差与到达时间均值/方差；
  * `corridor_components`（可选增强）：输出 $K$ 个分量（常用 $K=1\sim 2$），每个分量提供 weight/mean/cov，用于多峰走廊表达（见 4.3）。

第二阶段输出：

* `corrected_state`：至少包含 $\hat{v}^+$；可选包含 $\hat{a}_{xz}$。
* `updated_corridor`：基于新权重与校正结果更新后的走廊（建议优先输出平面走廊）。

补充约定：

* 时间基准：`t_b` 为反弹事件时间；第二段时间统一用 $\tau=t-t_b$（相对时间），避免混用。
* 轨迹表示：

  * 若输出采样序列：固定 `dt`，并显式提供 `t0=t_b`、`dt`、`num_samples` 或 `t_list`；
  * 若输出参数化：明确参数含义（例如 $(p_b, v^+, a)$）。
* 协方差单位：位置协方差单位 $\mathrm{m}^2$，时间方差单位 $\mathrm{s}^2$。

### 2.3.1 输出字段的接口契约（推荐写死在代码里）

为避免“上游/下游各自理解不同”，建议把以下约束作为接口契约固化：

* `t_b` 一旦冻结（见 2.4.4），在未启用 5.5 的情况下不得随新 post 点变化。
* `valid/low_confidence` 必须显式输出，且给出原因码（例如：`no_real_root`、`too_few_points`、`residual_too_large`）。
* 走廊输出必须声明其表示法：`quantile` / `mixture` / `gaussian`，并声明置信水平（例如 5/95）。
* 对“平面穿越/落点”类输出，必须明确选择规则：本文档默认取反弹后的**下降穿越**。实现上建议用判据 $\tau>0$ 且 $\dot y(\tau)<0$（仅重力模型下 $\dot y(\tau)=v_y^+ - g\tau$）。

下面给出一个语言无关的“字段示例”（不是强制 API，仅用于对齐概念）：

* `prefit_event`: `{valid, reason, tb, pb(3), v_minus(3), sigma_tb?, sigma_v_minus?, prefit_rms?, state(pre/post)?, t_freeze?, transition_reason?}`
* `stage1`: `{candidates[M], corridor}`
* `stage2`: `{corrected_state, updated_weights[M], updated_corridor, diagnostics}`

### 2.4 第一段状态估计模块（必须项，保证 $(t_b,p_b,v^-)$ 的可靠性）

说明：本报告的两阶段预测性能对第一段输出高度敏感；若第一段包含离群点、时间戳误差或接触高度建模错误，后续候选与校正会被系统性污染并导致参数沉淀发散。

现实约束（必须明确写进设计假设）：

* **反弹点不可见是常态**，尤其是反弹附近的若干帧。
* 因此第一段模块的核心任务不是“拟合整段曲线”，而是稳定估计一组事件参数 $(t_b,p_b,v^-)$ 及其不确定度尺度。
* 第二段出现少量点后，也应避免让这些 post 点反向污染 prefit（否则 $t_b$ 易漂移）。若确实需要利用 post 点信息修正 $t_b$，应当走“联合估计/小范围优化”的路径（见 5.5）。

#### 2.4.1 接触条件（球心高度偏置）

相机观测 $p(t)$ 通常为球心位置。触地事件不应默认 $y=0$，而应满足：

$$
y(t_b) = y_{\text{ground}} + r + b_y
$$

其中 $r$ 为球等效半径（可固定或标定），$b_y$ 为系统性高度偏置（相机外参/地面平面误差等）。工程建议：将 $y_{\text{ground}}+r+b_y$ 作为可配置的“接触高度”参数，避免硬编码。

#### 2.4.2 低算力高稳定的拟合/滤波建议（RK 友好）

推荐使用“短窗口、物理一致的 3D 低维模型”，避免高阶多项式外推：

* 竖直方向固定重力：

  $$
  y(\tau)=y_0+v_{y0}\tau-\tfrac12 g\tau^2
  $$
* 水平面允许等效常加速度（吸收未建模效应导致的水平系统偏差）：

  $$
  x(\tau)=x_0+v_{x0}\tau+\tfrac12 a_x\tau^2,\quad
  z(\tau)=z_0+v_{z0}\tau+\tfrac12 a_z\tau^2
  $$

其中 $\tau = t-t_{\text{ref}}$（窗口起点归零以改善数值稳定性），$-g$ 固定不拟合。

**工程实现约束（v3 规范，避免歧义）**：

* 第一段 prefit 的水平面 **强制** 使用等效常加速度模型（即二次项），不再提供“线性退化模式”。原因：

  * 线性模型会把未建模效应（旋转/气动/观测系统偏差）硬挤进速度项，导致 $v^-$ 与 $t_b$ 对离群点更敏感。
  * 若鲁棒重加权/残差评估使用的模型与最终 $v^-$ 输出模型不一致，会出现自相矛盾的权重更新（稳定性显著变差）。

* 实现必须在短窗口内使用 $\tau=t-t_{\text{ref}}$ 做时间归一（数值稳定性要求），并在同一套模型上完成：拟合 → 鲁棒重加权 → 求根 → 不确定度尺度估计。

#### 2.4.3 鲁棒性（必需）

* 使用真实时间戳（不假设等间隔）。
* 加权最小二乘：可按观测置信度/距离设置权重。
* 异常点处理：建议“1 次重加权/剔除”即可：
  1）加权最小二乘初解；
  2）计算残差，超过阈值的点权重置小或剔除；
  3）再做一次加权最小二乘。

输出：$(t_b,p_b,v^-)$ 及其不确定度（至少给出速度噪声尺度），用于 4.2 权重先验与 5.3 残差打分中的 $R$。

#### 2.4.3.1 可选增强：在 prefit 阶段使用 2D observation 做门控/降权（不改变分段契约）

本报告强调“prefit 只消费反弹前点并冻结事件锚点”（见 2.4.4）。在不改变该契约的前提下，2D observation 在 prefit 阶段仍有两类非常实用且 RK 友好的用途（对应 `2d observation.md` 的第 1/2 层）：

1）**帧内小优化/修正三角化（第 1 层）**：

* 对每个 3D 观测点 $p_i$，若具备 $\{z_{ij},\Sigma_{ij}\}$ 与 $\pi_j$，可做 1–2 次 Gauss-Newton/LM，最小化像素重投影残差以得到更一致的 $\tilde p_i$，再将 $\tilde p_i$ 输入 prefit 的 3D 拟合。
* 失败即回退：任一相机投影失败、雅可比数值不稳定、或有效相机数不足时，直接使用原始 `ball_3d_world`。

2）**像素一致性打分用于门控/权重（第 2 层）**：

* 对每帧计算像素残差（例如 whiten 后的 $\|r_{ij}\|$）与通过门控的相机数，将其汇总为点级质量指标 $q_i$（例如有效相机数越多、残差越小，$q_i$ 越大）。
* 在 prefit 的加权最小二乘/鲁棒重加权中，用 $q_i$ 对该 3D 点降权或剔除；这能显著减少“远距离深度抖动/错关联点”对 $t_b$ 与 $v^-$ 的污染。

注意：prefit 阶段的 2D 使用应以“提升鲁棒性与诊断性”为第一目标，而不是把 prefit 变成全量像素域轨迹拟合；后者更适合放在 5.6 的 posterior 像素域精修中，并且必须严格受算力预算与回退规则约束。

#### 2.4.4 反弹点不可见时的分段原则（避免灾难性漂移）

当反弹点不可见时，数据常出现“反弹前最后一段下降点 + 反弹后若干上升点”之间存在时间空洞。
这时如果把 post 点直接混入第一段拟合，往往会导致：

* 触地求根被推迟（等效为 $t_b$ 变大）。
* 第二段 $\tau=t-t_b$ 被系统性缩小或放大，从而放大落点误差。

因此建议把以下行为作为**接口契约**写死：

* 第一段模块只消费“反弹前点”来估计 $(t_b,p_b,v^-)$。
* “已进入反弹后段”的判定必须是**可执行且可回放复现**的（同一输入序列、同一参数下，触发时刻唯一）。推荐把它实现为一个二态事件检测器（状态机）：

  * 状态集合：`PRE_BOUNCE` / `POST_BOUNCE`。
  * 状态转移：只允许 `PRE_BOUNCE → POST_BOUNCE` 单向跳转（除非整段重置）。
  * 触发一旦发生，立即冻结 prefit 事件锚点，并记录冻结时刻 $t_{\text{freeze}}$（见下）。

  1）准备量（全部来自滑窗拟合，避免单帧差分抖动）：

  * 在 prefit 窗口内拟合竖直模型 $y(\tau)=y_0+v_y\tau-\tfrac12 g\tau^2$，得到窗口末端时刻的竖直速度估计 $\hat{\dot y}$（或直接用拟合得到的 $v_y$ 在末端求导）。
  * 记录窗口内最小高度 $y_{\min}$ 以及末帧高度 $y(t)$。

  2）判定条件（必要条件 + 充分条件，并做去抖/滞回）：

  * 必要条件（趋势反转，去抖）：

    * 先出现一段“稳定下降”，再出现一段“稳定上升”。
    * **工程实现建议（与 `curve_v3/utils/bounce_detector.py` 对齐）**：用“时间去抖”而不是“帧计数”去抖，避免不同 FPS 下行为漂移。
      记 $T_{\text{down}},T_{\text{up}}$ 为去抖时间常数：
      * 当连续一段时间满足 $\hat{\dot y} < -v_{\text{down}}$ 且累计时长 $\ge T_{\text{down}}$，认为“已确认下降”（`down_confirmed`）。
      * 在 `down_confirmed` 之后，当连续一段时间满足 $\hat{\dot y} > +v_{\text{up}}$ 且累计时长 $\ge T_{\text{up}}$，认为“已确认上升”。
      * 当趋势不明确时（例如 $\hat{\dot y}$ 在阈值附近抖动），累计时长清零，避免噪声下误触发。
      * 若你只有“按帧”实现能力，可近似取 $K\approx\mathrm{round}(T\cdot f)$，其中 $f$ 为 FPS。

  * 充分条件（高度接近触地/最小值附近，抑制噪声误触发）：满足以下任一项即可：

    * 末帧高度接近接触高度：$y(t) \le y_c + \epsilon_y$；或
    * 最近 $L$ 个观测点（或 $L$ 帧）内存在局部最小且最小值接近接触高度：$y_{\min} \le y_c + \epsilon_y$。

  其中：$v_{\text{up}},v_{\text{down}}$ 为速度阈值，$\epsilon_y$ 为高度容忍，$T_{\text{down}},T_{\text{up}}$ 为时间去抖常数，$L$ 为局部最小检查窗口（点数）。这些阈值必须给默认值并做成配置项。

  **实现备注（重要：反弹点不可见/缺帧时要优先保证“不会污染 prefit”）**

  现实数据里存在一种很“刁钻”的缺帧情形：

  * 观测不到落地点（最低可见点仍离地较高），例如 $y_{\text{down\_min}}=0.25\,\text{m}$；
  * 观测到反弹后的第一个球点高度也不低，例如 $y_{\text{up\_first}}=0.20\,\text{m}$。

    在该情形下，“近地条件”往往永远不成立（因为 $y$ 低于阈值的那些帧根本没有观测），如果仍坚持
    `vy_flip_and_near_ground` 这一条触发路径，就会出现：

    * `PRE_BOUNCE → POST_BOUNCE` 长时间不触发；
    * gap 右侧的点（实际上可能已经是 post 段）继续被喂进 prefit；
    * 触地求根被系统性推迟，导致 $t_b$ / $\tau=t-t_b$ 漂移（灾难性放大落点误差）。

    因此 **当检测到“明显可见性缺口（visibility gap）”时，应采用更保守、以隔离为目标的安全切分策略**。
    当前 v3 的落地实现（`curve_v3/utils/bounce_detector.py`）提供了一个可复现的兜底路径：

    * **gap-freeze（原因码：`visibility_gap_freeze`）**
      1. 在时间序列中寻找“最后一个明显缺口” $[t_k,t_{k+1}]$：若 $\Delta t_k=t_{k+1}-t_k$ 显著大于
         正常帧间隔（例如 $\Delta t_k>m\cdot\mathrm{median}(\Delta t)$），认为反弹附近可能不可见。
      2. 用 gap 左侧末端若干点拟合固定重力竖直模型（仅用于粗预测）：
         $$y(t)=y_0+v_y(t-t_{\text{ref}})-\tfrac12 g(t-t_{\text{ref}})^2$$
         并由此预测触地时刻 $\hat t_b$（解 $y(\hat t_b)=y_c$ 的正根）。
      3. 若 $\hat t_b\in[t_k-\delta,\ t_{k+1}+\delta]$（给一个小裕量 $\delta$），则**直接冻结**，并令
         `cut_index = k`（即把 pre 段截断在 gap 左侧最后一个可见点）。

    该策略的工程含义：它并不声称 $\hat t_b$ 很准；它的目标是“宁可切得略早/略保守，也要阻断 post 点回灌污染 prefit”。

    **关于 `low_confidence` 的表达方式**：文档层面建议你对 gap-freeze 这类“保守切分”显式标注低置信。
    当前实现没有单独的 `low_confidence` 布尔位，而是通过 `freeze_reason` 输出原因码；上层可按
    `freeze_reason==visibility_gap_freeze` 将该回合标记为低置信，并在需要时启用 5.5 的小窗口联合 $t_b$ 搜索作为兜底。

  **推荐默认阈值（与当前实现字段对齐，可直接落地）**

  > 设计目标：在“滑窗拟合得到的 $\hat{\dot y}$ 存在抖动、反弹附近可能缺帧”的现实条件下，优先保证 **不误触发** 与 **触发时刻唯一可复现**；如果因此稍微晚一点冻结，用 5.5 的小窗口联合 $t_b$ 搜索兜底。

  | 概念参数 | 默认值 | 单位 | 实现字段（`CurveV3Config`） | 含义 |
  | --- | ---: | --- | --- | --- |
  | $T_{\text{down}}$ | 0.03 | s | `bounce_detector_down_debounce_s` | “稳定下降”累计时长去抖 |
  | $T_{\text{up}}$ | 0.03 | s | `bounce_detector_up_debounce_s` | “稳定上升”累计时长去抖 |
  | $L$ | 7 | 点 | `bounce_detector_local_min_window` | 在触发时用尾窗局部最小选 cut |
  | $N_{\min}$ | 6 | 点 | `bounce_detector_min_points` | 点数过少时不触发 |
  | $v_{\text{down}}$ | 0.6 | m/s | `bounce_detector_v_down_mps` | 判定“稳定下降”的速度门限 |
  | $v_{\text{up}}$ | 0.4 | m/s | `bounce_detector_v_up_mps` | 判定“稳定上升”的速度门限 |
  | $\epsilon_y$ | 0.04 | m | `bounce_detector_eps_y_m` | 近地高度容忍（球心高度） |
  | gap-freeze 开关 | True | - | `bounce_detector_gap_freeze_enabled` | 是否启用“可见性缺口”安全冻结 |
  | $m$ | 3.0 | - | `bounce_detector_gap_mult` | gap 判定倍数：$\Delta t>m\cdot\mathrm{median}(\Delta t)$ |
  | $\delta$ | 0.033 | s | `bounce_detector_gap_tb_margin_s` | 判断 $\hat t_b$ 是否落在 gap 的裕量 |
  | $N_{\text{fit}}$ | 12 | 点 | `bounce_detector_gap_fit_points` | 拟合 $\hat t_b$ 用的 gap 左侧末端点数 |

  **随 FPS/噪声缩放建议（把默认变成“可迁移规则”）**

  * 若已知相机帧率为 $f$（Hz），建议把“去抖时间常数”而不是帧数写死：
    * $T_{\text{down}}\approx T_{\text{up}}\approx 0.03\,\text{s}$（约 30ms）。
    * 若检测器只能按帧实现，可取 $K\approx \mathrm{clip}(\mathrm{round}(T\,f),\ 2,\ 5)$。
    * $L \approx \mathrm{clip}(\mathrm{round}(0.07\,f),\ 5,\ 11)$（约 70ms）。
  * 若能从滑窗拟合残差估计竖直速度噪声尺度 $\sigma_{\dot y}$（m/s），建议用“噪声倍数”设门限：
    * $v_{\text{down}} = \max(3\sigma_{\dot y},\ 0.5)$。
    * $v_{\text{up}} = \max(3\sigma_{\dot y},\ 0.3)$。
    * 解释：用 $3\sigma$ 把误触发压低；最低下限用于避免在低噪声估计失真时门限过小。
  * 若能估计球心高度噪声 $\sigma_y$（m），建议：$\epsilon_y=\max(3\sigma_y,\ 0.03)$。
  * 若你在上层接入 `bounce_flag` 且其置信度标定不稳定（不同场景分布漂移大），不要把触发阈值设得太低；宁可让外部触发更“保守”，把主逻辑交给内部判定器 + gap-freeze +（必要时）5.5 兜底。

  3）外部触发（可选扩展，当前 v3 默认实现未在检测器内部消费）：

  * `bounce_flag`：上游检测器给出 bounce 事件（带置信度）；
  * `visibility_gap`：反弹附近缺帧/遮挡指示（若上游已算出，可直接用于强制冻结）；
  * `min_y_index`：上游给出最低可见点索引（注意它不是 $t_b$，仅用于约束窗口）。

  说明：`curve_v3/utils/bounce_detector.py` 当前只实现“内部判定 + gap-freeze 兜底”，没有 `bounce_flag` 的逻辑分支。
  若工程链路已有 `bounce_flag`，建议在更上层（调用方）直接将状态机强制切到 `POST_BOUNCE` 并冻结；
  并把原因码记录为 `external_trigger`（或你们系统的等价原因码），以便回放复现与排障。

  4）冻结时刻/冻结内容（必须契约化）：

  * 冻结时刻：$t_{\text{freeze}}$ 定义为“首次满足触发条件的那一帧时间戳”，必须记录并随日志输出。
  * 冻结内容：冻结 prefit 事件锚点 $(t_b^{(0)},p_b^{(0)},v^-)$，后续 post 点不得回灌重估该锚点。
  * 若启用 5.5：只允许输出一个独立的后验字段 $\hat{t}_b$（posterior），不得改写 $(t_b^{(0)},p_b^{(0)},v^-)$。
  * 原因码：触发时输出 `transition_reason`/`freeze_reason`。
    - 当前 v3 实现的原因码见 `curve_v3/utils/bounce_detector.py`：`vy_flip_and_near_ground`、`visibility_gap_freeze`。
    - 若你在上层实现外部触发（例如 `bounce_flag`），建议统一用 `external_trigger`（或等价字段）记录。
* 若希望进一步提升 $t_b$ 的准确度，应交由第二阶段的“联合估计 $t_b$”处理，而不是把 post 点塞回第一段（见 5.5）。

---

## 3. 方案总览（闭环）

本方案由四部分组成：

1. 反弹事件最小物理结构：给出结构正确的 $v^+$ 生成方式。
2. 多假设候选与走廊：用少量候选覆盖不可辨识因素，第一阶段输出“走廊”而非单点真值。
3. 少点强校正：第二阶段用低维线性模型在 $N\le 5$ 下快速收敛。
4. 在线沉淀：将后验校正结果回灌到先验权重/参数池，逐步缩窄第一阶段走廊。

后验结果用于在线更新反弹参数先验，从而逐步缩窄第一阶段走廊并减少名义误差。

### 3.1 推荐的在线执行流程（伪代码）

下面给出一个“不会把接口玩坏”的最小闭环流程，便于实现与评审：

1. **prefit（仅消费反弹前点）**：估计 $(t_b,p_b,v^-)$ 与置信度（或残差尺度），并冻结。
2. **stage1（无 post 点时）**：生成候选 $(e,k_t,\phi)$ → 得到每候选 $v^{+(m)}$ → 输出走廊（优先按平面）。
3. **stage2（出现 $N\le 5$ 个 post 点时）**：对每候选做递推正则最小二乘（信息形式，见 5.2.2）→ 得到 $\hat{\theta}_m$ 与后验代价 $J_m^{\text{post}}$ → log-sum-exp 更新权重 → 输出 MAP 或混合均值，并更新走廊。
4. **online prior（可选）**：把后验权重/反推参数沉淀到分桶先验里（见第 7 章）。

---

## 4. 第一阶段：名义预测 + 走廊

### 4.1 反弹事件最小模型（可实现版本，v1.1）

将反弹前速度分解为法向与切向：

* $v_n^-=(v^-\cdot\hat{n})\hat{n}$
* $v_t^-=v^- - v_n^-$

法向采用恢复系数 $e$：

$$
v_n^+ = -e\, v_n^-
$$

切向部分在缺少自旋可靠观测时，不再仅用标量 $k_t$，而采用“切平面 $2\times 2$ 等效映射”以覆盖方向耦合（侧旋导致切向方向偏转）：

1）在切平面基 $(\hat{t}_1,\hat{t}_2)$ 下表示二维切向速度：

$$
u^-=
\begin{bmatrix}
v^- \cdot \hat{t}_1\\
v^- \cdot \hat{t}_2
\end{bmatrix},\quad
u^+=
\begin{bmatrix}
v^+ \cdot \hat{t}_1\\
v^+ \cdot \hat{t}_2
\end{bmatrix}.
$$

2）定义映射：

$$
u^+ = A u^-,
\quad A\in\mathbb{R}^{2\times 2}.
$$

工程上建议用低参数化，兼顾可解释与可离散候选：

* 各向同性缩放 + 小角度旋转：

  $$
  A = k_t R(\phi),
  \quad R(\phi)=
  \begin{bmatrix}
  \cos\phi & -\sin\phi\\
  \sin\phi & \cos\phi
  \end{bmatrix}.
  $$

其中 $k_t$ 吸收切向能量变化，$\phi$ 吸收“切向方向偏转”（侧旋/接触耦合等效项）。当 $\phi=0$ 时退化为原方案 $v_t^+ = k_t v_t^-$。

最终切向三维恢复：

$$
v_t^+ = (u^+_1)\hat{t}_1 + (u^+_2)\hat{t}_2.
$$

说明：该等效映射比“显式摩擦/滑滚状态机”更稳定、更易在缺少自旋观测时落地；同时引入 $\phi$ 可显著提升第一阶段走廊覆盖与名义稳定性。

### 4.2 候选生成（多假设）

将参数离散为少量分档。v1.1 默认引入 $\phi$ 分档，但可配置为 1 档（即关闭偏转项）以节省候选数。

* $e\in\{e_{\text{low}},e_{\text{mid}},e_{\text{high}}\}$
* $k_t\in\{k_{\text{low}},k_{\text{mid}},k_{\text{high}}\}$
* $\phi\in\{\phi_{\text{left}},0,\phi_{\text{right}}\}$（默认小角度，例如 $\pm(2^\circ\sim 8^\circ)$ 的范围，按数据调）

候选数：

$$
M = |e|\cdot|k_t|\cdot|\phi|.
$$

默认 $3\times 3\times 3=27$；若算力或工程复杂度要求更低，可将 $\phi$ 设为单档（$0$），退化回 $9$ 候选。

候选数 $M$ 是固定算力预算下的核心旋钮；建议作为配置项，不在代码中写死。

#### 4.2.1 候选参数的工程边界与初始化

* $(e,k_t,\phi)$ 的初始分档范围应来源于：历史数据标定、同场地在线沉淀结果或保守经验范围。
* 对所有参数做硬约束与裁剪（clamp），避免明显不物理/数值不稳定：

  * $e \in [e_{\min}, e_{\max}]$（例如 $e_{\min}>0$，$e_{\max}$ 可略大于 1 以容纳等效误差，但需谨慎）
  * $k_t \in [k_{\min}, k_{\max}]$（允许覆盖不同场地/旋转耦合；必要时允许符号变化，但需通过数据验证与裁剪）
  * $\phi \in [-\phi_{\max}, \phi_{\max}]$。

#### 4.2.2 候选轨迹生成（解析计算，固定仅重力）

为避免数值积分带来的算力与误差开销，本文档的工程方案将第二段飞行模型固定为“仅重力解析”。此时轨迹可解析计算：

$$
p(\tau) = p_b + v^{+(m)}\tau + \tfrac12 \mathbf{g}\, \tau^2.
$$
无需数值积分。

补充建议（来自线上排障经验）：

* 若你发现“落点系统性偏大/偏小”，第一优先嫌疑通常不是更复杂的飞行模型，而是 $t_b$ 的时间基准漂移。
* 建议先用 9.2 的验证清单确认 $t_b$ 是否稳定，再投入精力做模型误差项优化。

### 4.3 走廊输出（工程定义，支持多峰）

走廊用于为决策/滤波提供风险边界与权重来源。第一阶段若只输出单一曲线，存在在部分场景下出现较大偏差的风险；走廊用于把不可辨识因素以可计算的形式表达出来。

走廊输出需考虑候选集合可能“多峰”。因此 v1.1 推荐至少支持两种表示：

A）包络/分位数（多峰安全，默认可用）

* 对每个 $t_k$ 或拦截平面**下降穿越**点集合，输出 min/max 或 10/90、5/95 分位数包络。

B）混合分量（可选增强，推荐）

* 输出 $K$ 个分量（常用 $K=1\sim 2$）。每个分量给出 weight/mean/cov，分量可按候选参数分组（例如按 $\phi$ 或按 $k_t$ 分两簇）或按简单聚类得到。

若采用单高斯“均值+协方差”汇总，需知晓在多峰情况下会出现“椭圆过大或居中但漏覆盖”的风险，因此建议不要只提供单高斯一种形式。

#### 4.3.1 按时间输出（可选）

设第 $m$ 条候选在 $t_k$ 的投影为 $s_k^{(m)}=[x_k^{(m)},z_k^{(m)}]^\top$，权重为 $w_m$，且 $\sum_m w_m=1$。

均值/协方差（单分量）：

$$
\mu_k = \sum_{m=1}^M w_m\, s_k^{(m)},\qquad
\Sigma_k = \sum_{m=1}^M w_m\,(s_k^{(m)}-\mu_k)(s_k^{(m)}-\mu_k)^\top.
$$

或输出分位数包络/多分量。

#### 4.3.2 按拦截平面输出（推荐默认）

* 对每条候选求与目标平面的**下降穿越**点与到达时间，将候选集合汇总为 $(x,z)$ 的包络/分位数或均值/协方差，以及 $t$ 的均值/方差（或分位数）。

实现要点（解析优先）：

* 在“仅重力”模型下，穿越平面 $y(\tau)=y_0$ 可解析解二次方程；若存在两根，必须选取反弹后的**下降穿越**根：$\tau>0$ 且 $\dot y(\tau)<0$（即 $v_y^+ - g\tau < 0$）。
* 若解析实现不方便，也可用“符号变化检测 + 二分”做数值求根，但同样必须用 $\dot y(\tau)<0$ 判据选取下降穿越。

对不穿越目标平面的候选（高度不足/飞出边界）需定义策略：剔除并重归一化权重，或输出 `invalid` 标志并保留原因码。

---

## 5. 第二阶段：$N\le 5$ 少点强校正（v1.1：按候选后验打分，避免早锁错分支）

### 5.1 估计量选择（默认 5 维，支持退化）

默认估计：

* 反弹后初速度 $v^+\in\mathbb{R}^3$
* 水平等效常加速度 $a_{xz}=[a_x,a_z]^\top\in\mathbb{R}^2$

补充约定：

* 第一阶段候选生成时默认 $a_{xz}=0$（仅重力解析主干）；$a_{xz}$ 仅作为第二阶段的少点校正项，用来吸收短时段水平系统偏差。

退化模式：

* 若旋转影响弱或观测噪声大，可仅估计 $v^+$（3 维），降低过拟合风险。

### 5.2 校正模型（短窗口，线性）

对观测点 $p_i$，令 $\tau_i=t_i-t_b$：

$$
p_i = p_b + v^+\,\tau_i + \tfrac{1}{2}\mathbf{g}\,\tau_i^2 + \tfrac{1}{2}[a_x,0,a_z]^\top\tau_i^2.
$$

写为线性形式：$p_i - p_b - \tfrac{1}{2}\mathbf{g}\,\tau_i^2 = H_i\theta$，其中

* $\theta=[v_x^+,v_y^+,v_z^+,a_x,a_z]^\top$，
* $H_i\in\mathbb{R}^{3\times 5}$：

$$
H_i =
\begin{bmatrix}
  τ_i & 0 & 0 & \tfrac{1}{2} \tau_i^2 & 0 \\
0 & \tau_i & 0 & 0 & 0 \\
0 & 0 & \tau_i & 0 & \tfrac{1}{2} \tau_i^2
\end{bmatrix}.
$$

把所有点堆叠可得一个很小的线性系统。若用带先验的正则最小二乘（等价形式），其闭式解为：

$$
\hat{\theta}_m = (H^\top W H + \Lambda)^{-1}(H^\top W y + \Lambda\theta_m^0).
$$

实现要点（RK 友好）：

* $H^\top W H + \Lambda$ 应为对称正定（通过 $\Lambda$ 保证），推荐用 Cholesky 分解求解，避免显式求逆。
* 当 $N$ 很小或 $\tau$ 分布过窄导致病态时，优先切换到 `v_only`（3 维）或增大对 $(a_x,a_z)$ 的正则强度。

### 5.2.1 必须项：带先验/正则（避免 N 小时 $a_{xz}$ 过拟合）

为保证 $N\le 5$ 的稳定性，v1.1 推荐用“带先验的正则最小二乘”（实现统一用 5.2.2 的信息形式；等价于把候选给出的初值当先验）：

$$
\hat{\theta}_m = \arg\min_{\theta}\ \left\|W^{1/2}(H\theta-y)\right\|^2 + \left\|\Lambda^{1/2}(\theta-\theta^0_m)\right\|^2.
$$

其中：

* $y$ 为堆叠后的观测项；
* $W$ 为观测权重（可由 $R^{-1}$ 构造；若未知可先用单位阵并在实验中标定）；
* $\theta^0_m$ 为候选 $m$ 的先验（由候选 $v^{+(m)}$ 给出；$a_{xz}$ 先验可设为 0 或来自数据驱动输出均值）；
* $\Lambda$ 为正则矩阵，工程上应当对 $(a_x,a_z)$ 给予更强约束（更大权重），避免把噪声解释为巨大横向加速度。

这是一个 $5\times 5$（或 $3\times 3$）的小型线性系统，RK 上可稳定实时解算。

补充建议（稳定性 > 极限精度）：

* 观测权重 $W$ 建议支持按轴不同（例如 $y$ 更准/更不准都可能发生，取决于标定与视角），不要强行用单位阵。
* 若 post 点可能有误检/跳变，建议对单点残差做门限 gating：超阈值的点降权或丢弃，再解一次（与 2.4.3 的两步鲁棒一致）。

### 5.2.2 统一实现：递推的正则最小二乘（信息形式，推荐默认）

工程实践上不建议同时维护两套解算器（例如“批量版”和“递推版”）：

* $N\le 5$ 的场景下，最简单且最稳的实现，是统一使用**信息形式**维护法方程（信息矩阵/信息向量）。
* 点到点更新：每来一个点就更新一次，并可选择立刻求解输出。
* 批量更新：把 $N$ 个点依次递推更新后，再统一求解一次。
* 这样可以把**先验/正则**天然融入初始化，避免两套实现出现差分行为。

记观测方程为 $y_i = H_i\theta + \epsilon_i$，其中 $\epsilon_i\sim\mathcal{N}(0,R_i)$，令 $W_i=R_i^{-1}$。
对候选 $m$ 的先验 $(\theta_m^0,\Lambda)$，用信息形式初始化：

$$
A_m \leftarrow \Lambda,\qquad b_m \leftarrow \Lambda\theta_m^0.
$$

每来一个 post 点（或批量遍历每个点）做一次递推更新：

$$
A_m \leftarrow A_m + H_i^\top W_i H_i,\qquad
b_m \leftarrow b_m + H_i^\top W_i y_i.
$$

需要输出时（每点输出/最终输出都可以），用 Cholesky 解小型 SPD 线性系统：

$$
\hat{\theta}_m = A_m^{-1} b_m\quad\text{（实现中不要显式求逆，解 }A_m\hat\theta_m=b_m\text{）}.
$$

补充说明：

* 默认不使用遗忘因子（等价 $\lambda=1$），因为这里的窗口极短，优先保证可复现与稳健。
* 若确实需要轻微时变，可做 $A_m\leftarrow \lambda A_m + H_i^\top W_i H_i$、$b_m\leftarrow \lambda b_m + H_i^\top W_i y_i$，并建议 $\lambda\in[0.98,1]$ 且仅在验证确有收益后启用。
* 参数协方差近似可用 $\mathrm{Cov}(\hat\theta_m)\approx A_m^{-1}$（同样不建议显式求逆，可在需要时解若干个线性方程获得对角或特定方向方差）。

### 5.2.3 实现口径说明（与代码一致，避免“公式对了但口径不一致”）

本章 5.2.1–5.2.2 给出的写法是“通用形式”（允许每点 $R_i$ / $W_i$ 不同）。实际工程落地时，常见的第一版会做一些**刻意的简化**来换取稳定与可调参性；为了避免评审时“以为实现了一个更通用版本”，这里把**当前实现口径**明确写出来：

1）**观测噪声口径**

* 当前实现通常用一个标量位置噪声尺度 $\sigma$（单位：m）统一 $x/y/z$ 三个轴，并等价取
  $$
  W_i = \frac{1}{\sigma^2} I_3.
  $$
* 代入信息形式更新，就变成带一个全局缩放的更新：
  $$
  A_m \leftarrow \lambda A_m + \frac{1}{\sigma^2} H_i^\top H_i,\qquad
  b_m \leftarrow \lambda b_m + \frac{1}{\sigma^2} H_i^\top y_i.
  $$

2）**先验/正则口径**

* 先验中心来自候选：$\theta_m^0$ 至少包含候选给出的 $v^{+(m)}$，并通常令 $a_{xz}^0=0$（或来自数据驱动的桶均值）。
* 正则矩阵 $\Lambda$ 工程上通常取对角（或近似对角），且对 $a_x,a_z$ 的正则更强，以压制 $N\le 5$ 时的横向过拟合。

3）**后验代价 $J^{\text{post}}$ 的缩放（这会直接影响 5.4 的温度/权重）**

* 在使用标量 $\sigma$ 的口径下，可将 5.3 的打分写为：
  $$
  J_m^{\text{post}} = \frac{1}{\sigma^2}\lVert H\hat\theta_m-y\rVert^2 + (\hat\theta_m-\theta_m^0)^\top\Lambda(\hat\theta_m-\theta_m^0).
  $$
* 这与 5.3 的“$\|W^{1/2}(\cdot)\|^2$”完全等价，只是把 $W$ 的具体取值写死了。
* 由于 $\sigma$ 会线性缩放数据项，$\beta_N$（5.4）本质上也在吸收“噪声口径/打分尺度”的不确定性：当你没有可靠的 $\sigma$ 标定时，把 $\beta_N$ 作为温度做保守调参是合理的。

4）**递推 vs 批量的一致性（便于单测与排障）**

* 处理完所有点后，总信息矩阵/向量为：
  $$
  A_m = \Lambda + \sum_i H_i^\top W_i H_i,\qquad
  b_m = \Lambda\theta_m^0 + \sum_i H_i^\top W_i y_i.
  $$
* 无论你“批量堆叠一次性构造 $H,y$”还是“按点递推更新 $A,b$”，只要 $W/\Lambda$ 口径一致，最终解 $A_m\hat\theta_m=b_m$ 应一致；这也是建议统一用信息形式的主要原因。

### 5.3 与第一阶段候选融合（v1.1：对每个候选先校正再打分，降低锁错）

v1.1 推荐执行顺序（关键改动）：

1）对每条候选 $m$：构造先验 $\theta^0_m$（至少含 $v^{+(m)}$），对观测点做递推正则最小二乘（信息形式，见 5.2.2），得到 $\hat{\theta}_m$。
2）计算每条候选的后验代价 $J_m^{\text{post}}$（建议用加权残差 + 正则项）：

$$
J_m^{\text{post}} = \left\|W^{1/2}(H\hat{\theta}_m-y)\right\|^2 + \left\|\Lambda^{1/2}(\hat{\theta}_m-\theta^0_m)\right\|^2.
$$

3）用 $J_m^{\text{post}}$ 更新候选权重 $w_m$ 并归一化（见 5.4 数值稳定）。
4）输出策略：

* 名义输出：推荐取后验代价 $J_m^{\text{post}}$ 最小的候选对应的 $\hat{\theta}_m$（实现上最直观，且在 $N$ 很小时更不容易被先验权重放大成“早锁错”）；若你希望严格按离散后验做决策，也可取更新后权重最大的候选（$\arg\max w_m$）。
* 更稳的输出：用权重加权得到混合均值（尤其用于走廊更新与拦截风险评估）。

该流程的工程意义：避免在 $N=1,2$ 时由于噪声造成“先选错分支再强行拟合自洽”，显著降低锁错概率。由于 $M$ 很小（$9$ 或 $27$）且 $\theta$ 维度最多 5，额外计算完全可控。

#### 5.3.1 两层 MAP 的工程理解（连续参数 + 离散候选）

这套两阶段融合在工程上可以理解成“两层 MAP / 两个层次的后验问题”（这样更容易把 5.2 与 5.4 的角色对齐）：

1）**层 1：给定候选 $m$，对连续参数 $\theta$ 做 MAP**

* 给定候选先验中心 $\theta_m^0$ 与正则 $\Lambda$，用 5.2 的信息形式解出
  $$
  \hat\theta_m = \arg\min_{\theta}\ J_m(\theta)
  $$
  其中 $J_m(\theta)$ 是“数据项 + 先验项”的平方损失（5.2.1）。
* 这一步本质上是在每个候选分支上做一个小维度的 MAP 校正（continuous MAP）。

2）**层 2：在候选索引 $m$ 上做离散后验/近似 MAP（通过权重更新实现）**

* 你可以把每条候选当成一个离散隐变量 $m\in\{1..M\}$。第一阶段给出先验权重 $w_m^0 \approx P(m)$。
* 第二阶段在每个候选上得到一个后验代价 $J_m^{\text{post}}$ 后，通过 5.4 的形式更新
  $$
  \log \tilde w_m = \log w_m^0 - \tfrac12 \beta_N J_m^{\text{post}},
  $$
  并归一化得到 $w_m \approx P(m\mid\text{post points})$。
* $\beta_N$ 的作用可以理解为“在点很少时不把代价当成过强证据”，避免离散后验过早塌缩到单一候选。

3）**为什么实现里常见“先看 $J$、再看 $w$”的选支规则**

* 当 $N$ 很小时，$w_m^0$ 的不确定性往往不比数据项更小；此时直接用 $\arg\max w_m$ 可能把先验的小偏差放大成错误分支锁死。
* 因此实现上常用的稳妥策略是：优先选 $J_m^{\text{post}}$ 最小的候选（等价先保证“解释得通数据”），再用权重做 tie-break 或用于走廊/风险输出。

这也是为什么在工程实现中，**“连续参数的 MAP（解 $\hat\theta_m$）”与“离散候选的权重更新（更新 $w_m$）”必须同时存在**：前者负责快速把单候选拉到合理轨迹，后者负责避免早期错误分支被过度自信地锁死。

### 5.4 权重更新（数值稳定 + 温度控制，必需）

若观测噪声可近似高斯，可设：

$$
\log \tilde{w}_m = \log w_m^0 - \tfrac12 \beta_N J_m^{\text{post}}
$$

其中：

* $w_m^0$ 为第一阶段先验权重（来自数据驱动或均匀分布/历史沉淀）。
* $\beta_N$ 为温度/置信度系数：在 $N$ 很小时取小一些，避免过早极端自信；随 $N$ 增大逐步接近 1。

归一化必须采用 log-sum-exp，避免嵌入式 exp 下溢：

$$
w_m = \exp\Big(\log \tilde{w}_m - \mathrm{LSE}(\{\log \tilde{w}_j\})\Big).
$$

建议默认：当 $N\le 2$ 时 $\beta_N<1$，当 $N\ge 4$ 时 $\beta_N\to 1$（具体数值按实验校准）。

### 5.5（增强项）：联合估计 $t_b$ 与 post 状态

本报告的 v1.1 默认流程是“两段式”：

* 第一段 prefit 估计 $t_b,p_b,v^-$；
* 第二段 posterior 在固定 $t_b$ 的前提下拟合 $v^+$（以及可选 $a_{xz}$）。

当反弹点不可见/反弹附近缺帧时，仅靠第一段定准 $t_b$ 可能不够稳。
这时更稳的做法是把 $t_b$ 作为后验的一部分一起优化，减少对 prefit 根的敏感性。

工程上推荐的最小实现（稳定、可控、易上线）：

* 在 prefit 给出的 $t_b$ 附近做小窗口一维搜索/网格搜索：
  $$t_b \in [t_b^{(0)}-\Delta,\ t_b^{(0)}+\Delta].$$
* 对每个候选 $t_b$：用 $\tau=t-t_b$ 构造后验残差并打分；
* 加入一个很弱的先验惩罚项，避免 $t_b$ 为了贴合少量噪声点而乱漂：
  $$J = J_{post}(t_b) + \frac{(t_b-t_b^{(0)})^2}{\sigma_{t_b}^2}.$$

注意：

* 该增强项的目标不是让 $t_b$ “绝对精确”，而是让 $t_b$ 随 $N$ 变化更稳定、避免灾难性漂移。
* 建议始终配合 9.2 的诊断曲线使用：一旦发现 $t_b$ 仍随 $N$ 漂移，应先回到第一段分段与鲁棒性问题，而不是继续加复杂模型。

### 5.6（增强项）：像素域闭环精修（重投影误差最小化，RK 友好）

本节回答一个常见工程问题：

* “我已经拿到了 3D 点 $p_i$，为什么还要保留 2D 观测 $(u,v)$？”
* “如何在不破坏 RK3588 实时性的前提下，提高拟合精度上限？”

结论：

* 3D 点域拟合（5.2）是稳定、便宜且足够强的默认路径。
* 当存在多相机 2D 观测并且相机投影模型可用时，可以在 5.2 的基础上做一个很轻量的“像素域闭环精修”（B-lite），通常能显著抑制远距离/弱视差带来的深度抖动，并提供可诊断的重投影统计。

适用范围与放置位置说明（避免误解）：

* 像素域闭环并不是“只能用于 postfit”的算法：只要有每相机 2D 观测 $(u,v)$ 与投影模型 $\pi_j$，并且你有一个可参数化的 3D 轨迹模型（第一段/第二段都可以），理论上都可以在像素域最小化重投影误差。
* 本文档把它放在第 5 章（第二阶段）是出于工程默认落地策略：当前仓库的闭环精修接入点是 stage2 的候选后验校正（5.2 之后的“B-lite 精修”）。原因是：

  * stage2 参数维度小（3 或 5 维）且 $N\le 5$，计算预算固定且易于在 RK3588 上保底；
  * stage2 天然有一个非常强的 warm-start（先做 5.2 的 3D 线性 MAP），非线性优化更稳，不容易被坏点拖偏；
  * prefit 输出的 $t_b,p_b,v^-$ 是整个系统的时间基准与先验来源，工程上通常优先保持其“短窗口 + 鲁棒 + 可解释 + 易回退”的闭式/近闭式路径，避免把标定偏差/错关联等像素域风险直接引入 $t_b$ 漂移。

* 若你确实希望在 prefit 里也利用 2D，建议优先从 5.6.1 的第 1/2 层做起（用 2D 稳三角化、用像素残差做门控/定价），再考虑把第一段的模型参数也做 B-lite 像素域精修；后一种需要额外的门控与约束（例如屏蔽 bounce 附近脏帧、对 $t_b$ 固定或弱先验约束，并且必须保留“一键回退到纯 3D”）。

#### 5.6.1 三层机制（从轻到重）

本节按“工程侵入程度从轻到重”给出三层使用方式，上线可逐步启用：

1）**用 2D 让三角化更稳（单帧小优化，可选）**

* 对每帧 3D 点 $P_i$，不要只做闭式三角化；而是用 2D 观测做一个很小的优化：

$$
\min_{P_i}\ \sum_j \rho\big( r_{ij}(P_i)^T\Sigma_{ij}^{-1}r_{ij}(P_i)\big),\quad r_{ij}(P_i)=\pi_j(P_i)-z_{ij}.
$$

* 未知量只有 3（$X,Y,Z$），迭代 1–2 次 GN/LM 即可，RK 上开销极小。

2）**用 2D 残差为 3D 点定价（权重/门控/剔除更可靠）**

* 即便你仍采用 3D 点域的 5.2 线性系统，保留 2D 也能用于：

  * 逐相机坏点定位：只剔除某相机某帧的观测，而不是整帧丢弃。
  * 估计每帧 3D 点的各向异性协方差（或简化为标量权重），用于加权最小二乘。
  * 统一的像素门控：例如“至少 $K$ 个相机重投影残差在阈值内才更新”，否则仅预测。

3）**直接在像素域拟合/精修（精度上限通常最高）**

* 直接把 stage2 的数据项从“3D 残差”替换为“像素重投影残差”，目标函数为：

$$
\min_{\theta}\ \sum_{i,j}\rho\big( (\pi_j(P(t_i;\theta))-z_{ij})^T\Sigma_{ij}^{-1}(\pi_j(P(t_i;\theta))-z_{ij})\big)\ +\ (\theta-\theta_0)^T\Lambda(\theta-\theta_0).
$$

其中：

* $\theta$ 为 stage2 的低维参数（本文档默认为 $v^+$ 与可选 $a_{xz}$）。
* $\theta_0$ 与 $\Lambda$ 来自候选先验（与 5.2.1 的 MAP 一致）。
* $\rho(\cdot)$ 为 Huber 等鲁棒核，用于压制错关联/坏相机观测。

#### 5.6.2 B-lite 推荐实现（保证 RK3588 可跑）

在线建议采用“先 3D 后 2D”的两步法（warm-start + 少迭代精修），避免把非线性优化变成不受控的大问题：

1）先用 5.2 的 3D 点域线性 MAP（信息形式）得到 $\theta$ 的初值（几乎免费）。
2）在像素域做 1–2 次 GN/LM（固定迭代上限），仅用于精修与一致性检验。

在“多候选（$M=9/27$）+ 少点（$N\le 5$）”的 stage2 场景里，像素域闭环应当遵循一个更关键的工程约束：

* **像素域精修不需要（也不建议）对所有候选都做**。
* 推荐策略是“候选层先粗后精”：

  1. 对所有候选 $m$，先用 5.2（3D 点域线性 MAP）得到 $\hat\theta_m$ 与 3D 口径的后验代价 $J_{m,3D}^{\text{post}}$（以及更新后的粗权重）。
  2. 选取 top-K 个候选（例如按 $J_{m,3D}^{\text{post}}$ 最小或按粗权重最大），仅对这 K 个候选做 5.6 的像素域 B-lite 精修，得到 $J_{m,px}^{\text{post}}$ 与精修后的 $\hat\theta_m$。
  3. 输出与权重更新时：

     * 对做过像素域精修的候选，用 $J_{m,px}^{\text{post}}$ 替换其 3D 数据项（并保留同一套先验/正则项）。
     * 对未精修的候选，仍使用 $J_{m,3D}^{\text{post}}$。

这样做的目的很明确：把像素域计算预算集中到最可能正确的少数分支上，**在不增加候选数与不破坏实时性的前提下，尽可能提升精度上限**。

推荐默认值（经验上对 RK3588 更稳）：

* `top_k = 1`：只对当前最优（MAP 或最小 $J_{3D}$）候选做像素精修（最省算力，风险最小）。
* `top_k = 2`：在边界场景（多峰更明显、$N=1..2$）通常更稳，但算力线性增加。

工程约束与默认值建议：

* 迭代次数：1–2（固定上限；即使收敛更慢也不继续迭代）。
* 参数维度：3 或 5（与 5.1 保持一致）。
* 鲁棒阈值：像素域 Huber $\delta$ 建议 2–4 px（按检测器抖动与标定误差调）。
* 协方差：若上游无法提供 $\Sigma_{ij}$，可先用 $\Sigma_{ij}=\sigma_{px}^2 I$ 的经验形式（清晰 0.5px，模糊 1.5px）并逐步标定。

为了避免“公式写得很漂亮，但实现一跑就数值炸掉”，这里把两个实现口径写死为规则（便于评审与单测对齐）：

* **白化矩阵的计算口径**：

  * 若使用一般协方差 $\Sigma_{ij}$，推荐用 Cholesky：$\Sigma_{ij}=LL^T$，白化用解三角系统实现 $\Sigma_{ij}^{-1/2}r = L^{-1}r$（不要显式求逆）。
  * 若 $\Sigma_{ij}$ 非 SPD（常见于上游拼装/数值误差），必须降级为各向同性 $\sigma_{px}^2 I$ 或直接丢弃该观测，并记录原因码。

* **数值雅可比（有限差分）的步长口径**（当你暂时没有解析雅可比时）：

  * 对每个参数分量 $\theta_d$ 使用“相对 + 绝对”步长：

    $$
    \Delta\theta_d = \max(\epsilon_{abs},\ \epsilon_{rel}\cdot\max(|\theta_d|,1)).
    $$

  * 工程默认可从 $\epsilon_{rel}=10^{-4}$、$\epsilon_{abs}=10^{-6}$ 起步，并在离线数据上标定；关键是要保证：

    1）不同量纲参数（速度 m/s、加速度 m/s$^2$）都能得到可用梯度；
    2）出现 NaN/Inf 或投影失败时能立刻降级回退。

时间复杂度直觉（用于 RK 预算评估）：

* 每次迭代的主要成本是投影与构建 $J^T W J$（规模最多 $5\times 5$），开销随“有效的 (帧,相机) 2D 观测数”线性增长。
* 在 $N\le 5$、相机数 2–4 的典型设置下，总投影次数量级为 $\mathcal{O}(\text{iters}\cdot(D+1)\cdot 2MN)$，远小于 2D 检测网络本身的开销。

实现口径（严谨版，便于评审对齐）：

* 数据项：对所有可用的 (帧 $i$, 相机 $j$) 2D 观测，构造重投影残差：

  $$r_{ij}(\theta)=\pi_j(P(t_i;\theta)) - z_{ij}\in\mathbb{R}^2.$$

* 白化：对每条观测用 $\Sigma_{ij}^{-1/2}$ 白化（或等价用 $W_{ij}=\Sigma_{ij}^{-1}$ 进入法方程）。
* 鲁棒：对标量代价 $s_{ij}=r_{ij}^T\Sigma_{ij}^{-1}r_{ij}$ 施加 Huber（或同级鲁棒核），把错关联/坏相机点的影响压下去。
* 先验/正则：保留与 5.2.1 相同的 MAP 先验项 $(\theta-\theta_0)^T\Lambda(\theta-\theta_0)$，避免 $N$ 很小时像素域优化漂移。

像素域后验代价的口径建议写死为与 5.3/5.4 同构（只是把数据项从 3D 残差换成像素残差）：

$$
J_{m,px}^{\text{post}} = \sum_{i,j}\rho\big((\pi_j(P(t_i;\hat\theta_m))-z_{ij})^T\Sigma_{ij}^{-1}(\pi_j(P(t_i;\hat\theta_m))-z_{ij})\big)
\ +\ (\hat\theta_m-\theta_m^0)^T\Lambda(\hat\theta_m-\theta_m^0).
$$

对应的权重更新仍按 5.4 的 log-sum-exp 做数值稳定归一（温度 $\beta_N$ 不变），这样“像素域闭环是否启用”只影响代价计算，不会引入另一套权重学。

一个可落地的 B-lite 伪代码（固定迭代预算）：

1）初始化：用 5.2 的 3D 线性 MAP 得到 $\theta\leftarrow\theta^{(0)}$，设置 LM 阻尼 $\lambda$（小正数）。
2）重复 $k=1..K$（建议 $K=1..2$，固定上限）：

* 收集所有有效观测对 $(i,j)$（投影可计算、$z_{ij}$ 有限值）。
* 计算残差 $r_{ij}(\theta)$；
* 计算每条观测的鲁棒权重 $w_{ij}$（由 Huber 对应的影响函数得到；实现上可用等效 IRLS 权重）；
* 构建雅可比 $J_{ij}=\partial r_{ij}/\partial \theta$。

  * 若实现侧暂时没有解析雅可比，可用有限差分，但必须：
    1）步长相对化（例如按参数尺度取相对步长），
    2）对数值异常（NaN/Inf）立即降级回退。

* 构建小型法方程（维度 $D=\dim(\theta)$，通常为 3 或 5）：

  先定义白化残差范数（用于鲁棒核的门控/权重）：
  $$
  e_{ij}=\lVert\Sigma_{ij}^{-1/2}r_{ij}\rVert_2.
  $$

  一个常用的 Huber 等效权重（IRLS）写法是：
  $$
  w_{ij}=\begin{cases}
  1,& e_{ij}\le \delta,\\
  \delta/e_{ij},& e_{ij}>\delta.
  \end{cases}
  $$

  其中阈值 $\delta$ 需要与白化口径一致：

  * 若使用各向同性 $\Sigma_{ij}=\sigma_{px}^2 I$，常把阈值直接按像素指定（例如 2–4px），等价于对 $\lVert r_{ij}\rVert_2$ 做 Huber 门控；
  * 若使用一般协方差 $\Sigma_{ij}$，建议在白化空间里使用阈值 $\delta$（无量纲），并把它作为可调参对离线数据标定。

  然后构建近似 Hessian 与梯度（把先验/正则并入）：
  $$
  A = \Lambda + \sum_{i,j} w_{ij}\, J_{ij}^T\Sigma_{ij}^{-1}J_{ij},\qquad
  g = \Lambda(\theta-\theta_0) + \sum_{i,j} w_{ij}\, J_{ij}^T\Sigma_{ij}^{-1}r_{ij}.
  $$

* 做 LM 更新（保证 SPD）：

  $$ (A + \lambda I)\,\Delta\theta = -g,\quad \theta \leftarrow \theta + \Delta\theta.$$

* 若出现数值问题（例如 $A$ 不可分解、$\Delta\theta$ 非有限、代价暴涨），立即终止并回退到 5.2 的 3D 输出。

说明：上述写法等价于“对堆叠后的像素残差做一次 GN/LM 的小维度更新”，并显式把先验/正则融入法方程；它的关键工程价值在于：

* 维度小、可控、可回退；
* 目标函数与传感器一致（像素域），更贴近可观测性；
* 输出可诊断（重投影误差分相机统计）。

#### 5.6.3 与 prefit 的关系（建议的工程落地顺序）

为避免把 5.6 误解为“只能用于第二阶段”，这里明确建议：

* 5.6 的像素域闭环属于通用技术：第一段/第二段都可以用，只要你有 2D 观测与投影模型。
* 但工程默认推荐把“第 3 层（像素域对轨迹参数精修）”先落在第二阶段：参数维度小、点少、warm-start 强、失败可回退，且不容易把像素域风险放大成 $t_b$ 漂移。
* 对第一段更推荐先落地第 1/2 层：用 2D 稳三角化、用重投影残差做门控/定价，从输入质量上提升 prefit 稳定性；若确要像素域优化第一段参数，也必须对 $t_b$ 做冻结/弱先验约束，并把 bounce 附近脏帧默认降权或剔除。

#### 5.6.4 何时启用/何时降级（必须可解释）

建议把启用条件与降级策略写成可回放的规则：

* 启用条件（同时满足）：

  * 有可用的 `obs_2d_by_camera`（至少一个点至少一个相机）；
  * 已注入相机投影模型 $\pi_j$；
  * 通过基础门控（例如可投影、像素坐标有限值）。

* 降级策略（任一触发即降级）：

  * 像素域迭代中出现不可逆/数值异常；
  * 有效 2D 观测不足；
  * 重投影误差显著异常（疑似错关联/标定失配），此时应回退到 3D 点域输出，并把 `low_confidence`/原因码打到日志里。

实现提示（避免“闭环炸点”）：

* 像素域闭环是增强项，不应改变主链路的鲁棒性：即使闭环失败也必须有稳定回退路径。
* bounce 附近 1–2 帧通常最脏（模糊/遮挡/反光/形变），建议在像素域里降权或直接剔除，以避免把触地点附近的脏点当成强约束。

---

## 6. 数据驱动（方案3）：增强先验，不做端到端整段曲线

### 6.0 定位与交付物（必须明确）

第 6 章的目标不是端到端预测整段曲线，而是把“新场地/新球况的反弹统计规律”注入到两阶段结构里：

* **Stage1**：走廊更贴近真实分布（更窄且不漏覆盖），名义更稳。
* **Stage2**：在 $N=1..2$ 时显著降低锁错率（先验压制不可能候选），并在 $N\le 5$ 下更稳定地快速收敛。
* 不引入新的数值敏感点：不引入数值积分实现，不依赖不可辨识自旋显式建模。

工程上建议把“数据驱动模块”的交付物固定为三类（按优先级）：

* A. **候选先验权重**：$\{w_m^0\}_{m=1}^M$（强烈推荐，最直接、收益最大，且与候选库严格一致）。
* B. **分档概率**：$P(e\in e_i),\ P(k_t\in k_j),\ P(\phi\in\phi_k)$（可选，便于解释与可视化），最终仍映射到 $\{w_m^0\}$。
* C. **校正项先验**：$a_{xz}$ 的均值/方差（可选但很值钱，用于 5.2.1 的 $\theta^0_m$ 与 $\Lambda$ 自适应）。

### 6.1 默认落地形态：分桶先验表（Dirichlet/EMA，强推荐）

工程上最稳、最容易在 RK 上落地的方式是：不训练大模型，维护一个“条件统计表”（分桶 prior table）。部署成本小、行为可解释、鲁棒性强。

#### 6.1.1 分桶条件特征（尽量只用 prefit 可得信息）

建议的最小特征集（强泛化、低耦合）：

* 速度档：$|v^-|$ 分 3 档（slow / mid / fast）。
* 入射角档：

  $$
  \alpha = \arccos\left(\frac{-v_n^-}{|v^-|}\right),\quad v_n^- = v^-\cdot\hat{n}.
  $$

  将 $\alpha$ 分 3 档（shallow / mid / steep）。
* 触地点区域档：用 $p_b$ 在场地平面分区（例如 $2\times 3$ 或 $3\times 3$ 网格，6–9 档）。

可选增强（有就用，没有也不影响主流程）：

* 场地 ID、区域 ID、球类型、湿度/温度（若可获得）。
* `prefit_rms`（更适合做“样本可靠性权重/过滤”，不强制用于分桶）。

桶数量示例：3（速度）×3（角度）×6（区域）= 54 个桶（非常可控）。

#### 6.1.2 每个桶存什么（核心）

对每个桶 $b$，建议存两类统计：

1）**候选权重计数（Dirichlet）**：维护 $\alpha_{b,m}$（$m=1..M$）。运行时直接归一化得到桶内先验：

$$
w^0_{b,m} = \frac{\alpha_{b,m}}{\sum_{j=1}^M \alpha_{b,j}}.
$$

初始化：$\alpha_{b,m}=\alpha_{\text{init}}$（例如 1.0 或 0.5），等价于均匀先验并天然带平滑，避免某候选权重变成 0（对 $N=1..2$ 的稳定性很关键）。

2）**可选：$a_{xz}$ 统计**：维护桶内的 $\mu_{b,axz}\in\mathbb{R}^2$、$\Sigma_{b,axz}\in\mathbb{R}^{2\times 2}$（或至少对角方差）。用于 6.4 的“正则自适应”。

内存量级直觉：54 桶 × 27 候选 ≈ 1458 个 float（再加少量 $a_{xz}$ 统计），RK 上几乎无压力。

### 6.2 新场地离线“冷启动”先验（强烈建议标准流程）

如果你觉得“在新场地上先做一轮先验建立带来的提升更大”，这个判断通常是对的。
原因很简单：系统主要不确定性来自“不可观测的接触/自旋/摩擦状态”，而新场地会显著改变 $(e,k_t,\phi)$ 的统计分布。
与其在线硬上复杂空气动力学，不如先把候选的先验分布压窄：走廊会立刻变小、名义预测也更稳。

离线冷启动的标准流程（不增加 RK 在线算力）：

1. **数据采集**：建议 50–200 条有效反弹样本；每条尽量包含反弹前稳定窗口 + 反弹后至少 6–10 个点（离线允许更多点，部署仍限制 $N\le 5$）。
2. **离线跑两阶段，生成软标签**：离线允许 $N_{\text{offline}}>5$，并建议开启 5.5 的联合 $t_b$（离线更需要减少时间基准误差污染）。输出每条样本的后验权重 $w_m$（不要只取 MAP；软权重更稳）。
3. **样本过滤（必须做）**：只用“可靠样本”更新先验，避免先验被坏样本污染。建议至少包含：

   * prefit 有效（有实根、$\tau_b>0$ 合理）。
   * `prefit_rms` < 阈值（按你的测量噪声定）。
   * 后验残差的数据项（见 6.3）< 阈值。
   * 若启用 $t_b$ 搜索：最优 $t_b$ 不贴边（贴边常是可疑解）。
   * $v_y^+$ 不离谱（异常大通常意味着时间基准问题）。

4. **更新 Dirichlet 计数（核心）**：样本落入桶 $b$ 后，按样本质量权重 $\kappa$（例如 0.2–2.0）更新：

   $$
   \alpha_{b,m} \leftarrow \alpha_{b,m} + \kappa\, w_m.
   $$

   若你希望支持“逐步遗忘/平滑”，也可以用 EMA 形式（上线后建议更保守，见 6.5）。

5. **同步更新 $a_{xz}$ 统计（可选但推荐）**：从离线 stage2 解中取 $\hat a_{xz}$，用加权 Welford 更新均值/方差（同样按样本质量加权）。
6. **输出产物**：建议输出 `prior_table.json`（或二进制）包含：桶定义与边界、候选定义（$e/k_t/\phi$ bins）、每桶 $\alpha_{b,:}$（或直接 $w^0_{b,:}$）与可选 $a_{xz}$ 统计，并做版本化（生成日期、场地 ID、配置摘要）。

### 6.3 在线使用方式（部署期行为规定）

1）**Stage1：如何使用先验**：

* 根据 prefit 的 $|v^-|$、入射角 $\alpha$、触地点区域（$p_b$ 分区）以及可用元信息，找到桶 $b$。
* 计算桶内候选先验 $w^0_{b,:}$（由 $\alpha_{b,:}$ 归一化得到）。
* 若桶样本量不足（用 $N_b = \sum_m \alpha_{b,m}$ 表示“经验量”），建议做保守混合，避免新桶过度自信：

  $$
  w^0 = \lambda_b\, w^0_{b} + (1-\lambda_b)\, w^0_{\text{global}},
  \quad
  \lambda_b = \frac{N_b}{N_b+N_0}.
  $$

  其中 $N_0$ 可取 30–100（按你的数据量与风险偏好调）。

2）**Stage2：如何使用先验做权重更新**：

* 5.4 里的 $w_m^0$ 用上述 $w^0$ 替换即可：

  $$
  \log \tilde{w}_m = \log w_m^0 - \tfrac12 \beta_N J_m^{\text{post}}.
  $$

* 强烈建议把 $J_m^{\text{post}}$ 拆成可诊断输出（至少打印/记录）：

  * `data_term`：加权残差 $\|W^{1/2}(H\hat\theta_m-y)\|^2$
  * `prior_term`：正则项 $\|\Lambda^{1/2}(\hat\theta_m-\theta_m^0)\|^2$

  这样能快速识别“正则主导导致假稳定”或“数据项异常导致早锁错”。

### 6.4 可选增强：$a_{xz}$ 先验与正则自适应（推荐）

若桶 $b$ 有 $a_{xz}$ 统计：

* 先验中心：在 5.2.1 的 $\theta_m^0$ 中，设置 $a_{xz}^0 \leftarrow \mu_{b,axz}$。
* 正则强度：对 $a_{xz}$ 子块设置

  $$
  \Lambda_{axz} \leftarrow \Sigma_{b,axz}^{-1}
  $$

  或使用对角近似 $\mathrm{diag}(1/\sigma_{a_x}^2, 1/\sigma_{a_z}^2)$（工程上更稳也更便宜）。

该增强通常能同时缓解两类线上问题：

* $a_{xz}$ 被噪声带着“乱飙”；
* $a_{xz}$ 被过强固定正则“压死”导致吸收不了系统性偏差。

### 6.5 线上自适应更新（慢更新 + 安全阀）

线上也可以更新 `prior_table`，但必须非常克制，否则会被误检/极端样本带偏。

建议默认写入触发条件：

* $N \ge 3$（$N=1..2$ 太容易锁错）。
* `data_term` 小于阈值（拟合确实好）。
* 若启用 $t_b$ 搜索：最优 $t_b$ 不在窗口边缘。
* 置信度/一致性检查通过（例如 $v_y^+$ 不离谱）。

写入方式推荐 EMA（慢更新）：

$$
\alpha_{b,m} \leftarrow (1-\eta)\alpha_{b,m} + \eta\,\alpha_{\text{init}} + \kappa\, w_m,\quad m=1..M
$$

其中：

* $\eta$ 建议很小（如 0.01–0.05），用于“缓慢遗忘/回归基线”，避免长期被早期偏差锁死。
* $\alpha_{\text{init}}$ 是桶的基线强度（与 6.1.2 初始化一致）。
* $\kappa$ 是本次样本对计数的增量强度（建议也小，如 0.1–0.5）。

如果你暂时不需要遗忘，设 $\eta=0$ 并直接做 $\alpha_{b,m} \leftarrow \alpha_{b,m}+\kappa w_m$ 也完全可行，工程上更直观。

保护与回滚（必须具备）：

* `prior_table` 必须版本化，并支持一键回滚到上一个稳定版本。
* 若线上监控到“锁错率/落点误差”突然变差，自动停止写入（freeze online update），进入只读模式。

### 6.6 评估指标与验收（把 Sec 6 做成闭环）

验证第 6 章收益，最建议的指标组合：

1. $N=1..5$ 的 MAP 锁错率曲线（核心）：先验增强应显著降低 $N=1..2$ 的锁错。
2. 落点误差随 $N$ 收敛曲线：看 $|e_{xz}|$ 与 $|e_t|$ 对比“无先验 vs 有先验（新场地表）”。
3. 走廊覆盖率/宽度：在 90/95% 覆盖率下走廊变窄且不漏覆盖。

---

## 7. 在线参数沉淀（让第一阶段逐渐变窄，v1.1：沉淀到分档权重/低参数 A）

目标：把第二阶段的后验信息沉淀回第 6 章的 `prior_table`（分桶 Dirichlet 计数 $\alpha_{b,m}$ 与可选 $a_{xz}$ 统计），从而让相同场地/球况下的第一阶段走廊逐步变窄、$N=1..2$ 锁错率下降。

说明：先验表的结构、冷启动流程、在线写入条件与安全阀已在第 6 章给出；本章仅补充“如何从 stage2 输出反推可沉淀的统计量”的计算细节，避免实现侧各自发挥导致口径不一致。


### 7.1 由第二阶段结果反推参数（用于统计沉淀）

第二阶段对候选 $m$ 得到 $\hat{v}^+$ 后，分解法向/切向：

* $\hat{e} = -\dfrac{\hat{v}_n^+}{v_n^-}$（要求 $v_n^-\neq 0$）
* 切向部分建议用“投影形式”的等效 $k_t$（保留符号一致性）：

  $$
  \hat{k_t} \approx \frac{\hat{u}^{+\top}u^-}{|u^-|^2}
  $$

  其中 $u^-,\hat{u}^+$ 为切平面 2D 速度。

若启用 $\phi$ 参数化，可进一步拟合 $A \approx k_t R(\phi)$ 的 $(\hat{k_t},\hat{\phi})$（低维解析或一两步迭代均可；也可直接沉淀到“分档权重”而不显式回归连续参数）。

工程上对 $(\hat{e},\hat{k_t},\hat{\phi})$ 必须做裁剪与异常检测：

* 分母过小、点不足或校正不稳定则跳过本次沉淀。
* 出现明显异常值只低权写入或记录为异常样本。

---

## 8. 配置项（建议做成可热更新）

说明：本章列出的是“文档层面的建议配置项/旋钮”，用于评审对齐口径与上线排障。

* 若你的实现已有既定字段名，可做一对一映射即可，不要求字面完全一致。
* 但无论字段名如何，这些旋钮应当具备：可回放复现、可热更新（或至少可在线切换）、并在日志中输出配置快照以便复现。

| 配置项                     | 含义                                  | 建议默认                |
| ----------------------- | ----------------------------------- | ------------------- |
| `e_bins`                | 恢复系数分档                              | 3 档                 |
| `kt_bins`               | 切向缩放分档                              | 3 档                 |
| `phi_bins`              | 切向偏转分档                              | 3 档（可设为 1 档关闭）      |
| `num_candidates`        | 候选数 $M$                             | 27（或 9 关闭偏转）        |
| `corridor_mode`         | `time` / `plane` / `both`           | `plane`             |
| `corridor_repr`         | `quantile` / `mixture` / `gaussian` | `quantile`（多峰安全）    |
| `corridor_components_k` | 混合分量数（若启用）                          | $1\sim 2$                 |
| `intercept_plane`       | 目标平面定义                              | 由拦截模块给定             |
| `flight_model`          | 第二段飞行主干（固定）                      | `gravity`（竖直仅重力解析；水平偏差由 $a_{xz}$ 校正项吸收） |
| `fit_mode`              | `info_form`                         | `info_form`（统一实现，见 5.2.2） |
| `fit_solve_policy`      | `incremental` / `final`             | `incremental`（每点更新可立即求解） |
| `fit_params`            | `v_only` / `v+axz`                  | `v+axz`             |
| `prior_regularization`  | $\Lambda$ 配置                        | 对 $a_{xz}$ 强约束      |
| `beta_schedule`         | $\beta_N$ 温度日程                      | $N$ 小时更保守           |
| `outlier_gate`          | 异常点门限                               | 必配                  |
| `tb_contact_height`     | $y_{\text{ground}}+r+b_y$           | 必配                  |
| `enable_joint_tb`       | 5.5：是否启用小窗口联合 $t_b$（`off`/`auto`/`on`） | `auto` |
| `joint_tb_delta`        | 5.5：搜索半窗 $\Delta$（s）                   | 0.02 |
| `pixel_refine_enabled`  | 5.6：是否启用像素域闭环精修（B-lite，增强项）        | `auto`（满足条件才启用，否则回退） |
| `pixel_refine_max_iters`| 5.6：像素域 GN/LM 最大迭代次数（固定上限）         | 1–2 |
| `pixel_refine_top_k`（建议新增） | 5.6：候选层先粗后精，只对 top-K 候选做像素域精修 | 1（RK 保守）或 2 |
| `pixel_huber_delta_px`  | 5.6：像素域 Huber 阈值（px）                    | 2–4 |
| `pixel_gate_tau_px`     | 2.2.1/5.6：单观测重投影门限（px，用于门控/剔除）      | 6–12（按标定误差与检测噪声调） |
| `pixel_min_cameras`     | 2.2.1/5.6：帧级门控最小有效相机数 $K$               | 2 |
| `bounce_detector_k`     | 2.4.4：趋势反转去抖次数 $K$（下降 $K$ 次 + 上升 $K$ 次） | 3 |
| `bounce_detector_l`     | 2.4.4：局部最小检查窗口 $L$（帧）                 | 7 |
| `bounce_detector_v_down`| 2.4.4：稳定下降门限 $v_{\text{down}}$（m/s）     | 0.6 |
| `bounce_detector_v_up`  | 2.4.4：稳定上升门限 $v_{\text{up}}$（m/s）       | 0.4 |
| `bounce_detector_eps_y` | 2.4.4：高度容忍 $\epsilon_y$（m，球心高度）       | 0.04 |
| `bounce_detector_c_thr` | 2.4.4：外部 `bounce_flag.conf` 门限 $c_{\text{thr}}$ | 0.80 |

补充建议：

* 候选数与输出时刻数共同决定算力上界。优先保证候选覆盖（减少灾难性偏差），其次再提高单候选采样密度。
* “仅重力模型”下应尽量走解析计算路径，避免数值积分。

关于 `pixel_refine_top_k`：若你的实现侧暂未提供该配置项，也可以在调用方策略层实现同等控制（例如只对 MAP 候选调用一次像素域精修），效果与节省算力的目的完全一致。

---

## 9. 测试与验收

保持你的原指标，但建议补充两点：

1）第一段模块的独立验收（否则难定位问题）：$t_b$ 偏差、$v^-$ 偏差统计与离群率。
2）第二阶段“锁错率”指标：在 $N=1..5$ 下 MAP 分支与最终误差的相关性，验证 v1.1 的“先校正再打分”确实降低锁错。

### 9.2 在线回放的验证清单（强烈推荐）

当你面对“$N\le 5$ 却突然炸掉/落点离谱”的问题时，最有效的排查顺序通常是：

1) **$t_b$ 是否随 $N$ 漂移**：
   * 漂移往往意味着 prefit 被 post 点污染，或反弹附近缺帧导致求根被拉偏。
2) **第一段拟合残差是否随 $N$ 暴涨**（例如 prefit RMS）：
   * 暴涨常见原因是分段错误或异常点未被鲁棒机制压住。
3) **后验的 $v_y$ 是否异常大**：
   * $v_y$ 异常大通常意味着 $\tau$ 被放大（本质仍是 $t_b$ 或时间基准问题）。

4) **像素域一致性是否异常（若你接入了 2D 观测/像素域闭环）**：
  * 建议按“每相机 / 全相机”统计重投影误差（均值、95% 分位），并随时间/点数作图。
  * 若重投影误差整体偏大但 3D 点域残差不大，常见原因：
    * 相机标定口径不一致（去畸变/外参坐标系/时间同步）；
    * 2D 检测与 3D 关联错配（错球/错帧）。
  * 若仅某个相机的误差显著偏大，优先怀疑该相机的 2D 观测质量或标定漂移；工程上应支持对单相机降权/剔除，而不是整帧丢弃。

5) **有效相机数是否退化**：
  * 统计每帧可用相机数（例如 >=2 才能可靠三角化；像素域闭环也需要足够观测约束）。
  * 当可用相机数持续偏低时，走廊必须变宽并触发降级策略（例如只输出走廊或仅预测）。

6) **是否频繁触发“像素域闭环降级”**：
  * 若像素域闭环属于增强项，必须允许失败并回退到 3D 点域输出。
  * 但若频繁回退，应记录原因码并作为上线验收项（例如：`camera_rig_missing`、`insufficient_2d_obs`、`projection_failed`、`pixel_refine_numerical_issue`）。

这些诊断字段应被写入评估报告，且能随 $N$ 作图查看趋势（而不仅仅是单次打印）。

### 9.3 把“落点误差”作为正式指标（与拦截任务直接相关）

仅看整段点 RMSE 往往不足以判断“拦截是否可用”。建议把第二次触地/落点作为正式指标输出：

* 定义落点为第二段轨迹与 $y=y_c$ 的**下降穿越**（其中 $y_c=y_{ground}+r+b_y$ 为球心触地高度）。
* 输出并随 $N$ 作图：
  * $|e_{xz}|$：落点位置误差（米）
  * $|e_t|$：落点时间误差（秒）

这能把“看起来差不多”的曲线差异，直接量化成任务相关指标，并且对 Step 1/Step 2 的收益更敏感。

---

## 10. 开源实现的最小落地清单（建议）

为了让读者能够“照着做就跑起来”，建议在代码实现与评估中至少包含以下字段与开关：

* 关键字段（用于回放复现与在线排障）：

  * 预拟合/分段：`tb`、`pb`、`v_minus`、`prefit_rms`、`sigma_tb?`、`state`、`t_freeze`、`transition_reason`、`low_confidence?`、`reason?`。
  * 候选与权重：`candidate_params`、`weights_before`、`weights_after`、`beta_N`。
  * 后验打分：`J_post`（建议每候选都可记录），以及可选的 `data_term` / `prior_term`（见 6.3）。

  * （若接入 2D/像素域闭环）像素域诊断：
    * `reproj_error_px_mean/p95`（建议按相机与全局都输出）
    * `num_valid_cameras`（每帧有效相机数统计）
    * `pixel_refine_enabled`、`pixel_refine_iters_used`、`pixel_refine_fallback_reason?`

* 关键配置（建议随日志输出一次 snapshot，避免“配置漂移导致无法复现”）：

  * 候选与走廊：`phi_bins`、`num_candidates`、`corridor_repr`（`quantile`/`mixture`）。
  * 第二阶段解算：`fit_mode=info_form`、`fit_solve_policy`、`fit_params`、`prior_regularization`、`beta_schedule`、`outlier_gate`。
  * 反弹事件/分段：`tb_contact_height`、`enable_joint_tb`、`joint_tb_delta`、`bounce_detector_*`（见 8 与 2.4.4）。

* 关键指标：拦截平面误差 + 落点误差（见 9.3），并能按 $N=1..5$ 画收敛曲线。

---

## 11. 风险与应对（补充）

* 多峰走廊：默认用分位数/包络或混合分量，避免单高斯椭圆误导。
* 早期锁错：采用 v1.1 的“每候选校正后验打分”流程 + 温度 $\beta_N$。
* 过拟合横向扰动：对 $a_{xz}$ 强正则/先验约束。
* 触地高度偏置：用 $y_{\text{ground}}+r+b_y$ 建模并可配置/标定。

## 附录B：第一段状态估计模块（反弹事件 $(t_b,p_b,v^-)$）参考规格（RK 友好）

### B.1 目标与输出

目标：从第一段观测点 $\{(t_j, p_j)\}$（球心三维位置）中，稳定估计反弹事件的

* 触地时刻 $t_b$
* 触地球心位置 $p_b$
* 触地前速度 $v^-$
* （建议）速度与事件时间的不确定度尺度（用于候选权重、走廊宽度与第二阶段权重矩阵）

### B.2 输入

最小输入：

* 第一段观测点：$\{(t_j, p_j)\}_{j=1..L}$，$p_j=[x_j,y_j,z_j]^\top$
* 接触高度参数：$y_c = y_{\text{ground}} + r + b_y$（球心触地高度）
* 重力常数：$g$

建议输入（可选但强烈推荐）：

* 每点置信度 $c_j\in(0,1]$ 或测量噪声尺度（用于加权）
* 观测丢帧/跳变标志（若上游可提供）

### B.3 滑动窗口与时间基准

使用滑动窗口，专注于“接触前最近一段”，避免长窗口模型失配。

* 窗口长度：建议最近 8–15 帧（或最近 200–400ms，取决于帧率与噪声）
* 时间归一：令 $t_{\text{ref}} = t_{L}$（窗口末帧时间），定义 $\tau_j = t_j - t_{\text{ref}} \le 0$。这样数值更稳定，且便于外推到 $\tau_b>0$。

### B.4 拟合模型（默认解析、线性可解）

默认使用“3D 常加速度近似 + 竖直方向固定重力”的模型（水平面二次项为必选）：

$$
x(\tau)=x_0+v_x\tau+\tfrac12 a_x\tau^2,\quad
z(\tau)=z_0+v_z\tau+\tfrac12 a_z\tau^2
$$

$$
y(\tau)=y_0+v_y\tau-\tfrac12 g\tau^2
$$

说明：

* $y$ 方向不拟合加速度，固定为 $-g$，可显著稳定 $t_b$ 与 $v_y^-$。
* $(x,z)$ 方向使用 $(a_x,a_z)$ 作为“等效加速度”，吸收未建模效应带来的水平系统偏差（短窗口内有效）。
* 该模型对参数是线性的，可用加权最小二乘一次解出。

参数集合：

* 水平：$\theta_x=[x_0,v_x,a_x]$，$\theta_z=[z_0,v_z,a_z]$（实现要求：该二次模型必须启用）
* 竖直：$\theta_y=[y_0,v_y]$（因 $-\tfrac12 g\tau^2$ 已知）

### B.5 加权与鲁棒（必需）

权重设计（示例）：

* 若有置信度 $c_j$：权重 $w_j = \mathrm{clamp}(c_j, w_{\min}, 1)$
* 若无置信度：可用距离/深度启发式，或统一 $w_j=1$

鲁棒两步法（推荐）：

1）一次加权最小二乘得到初解；
2）计算残差（建议用 3D 残差或分别对 x,y,z），超过阈值的点降权或剔除；
3）再做一次加权最小二乘得到最终解。

阈值建议：

* 先从“厘米级到分米级”按你的测量噪声定，且按窗口尺度可自适应（例如用 MAD 估计尺度）。

### B.6 触地时刻求解（解析优先）

由竖直模型外推求 $\tau_b>0$ 使得 $y(\tau_b)=y_c$：

$$
y_0+v_y\tau_b-\tfrac12 g\tau_b^2 = y_c
$$

这是二次方程，取物理可行根（$\tau_b>0$ 且最小正根通常对应下一次触地）。若判别式 <0 或根异常，标记为 `invalid_bounce` 并由上层降级处理（例如扩大走廊或等待更多点）。

得到：

$$
t_b = t_{\text{ref}} + \tau_b
$$

### B.7 触地点与触地前速度计算

触地点（球心）：

$$
p_b =
\begin{bmatrix}
x(\tau_b)\\
y(\tau_b)\\
z(\tau_b)
\end{bmatrix}
$$

触地前速度（球心）：

$$
v^- =
\begin{bmatrix}
\dot x(\tau_b)\\
\dot y(\tau_b)\\
\dot z(\tau_b)
\end{bmatrix}
=
\begin{bmatrix}
v_x + a_x\tau_b\\
v_y - g\tau_b\\
v_z + a_z\tau_b
\end{bmatrix}
$$

### B.8 不确定度输出（轻量版本）

为了支撑第一阶段候选权重与走廊宽度，建议至少输出两类尺度量（无需全协方差也可用）：

1）竖直触地时间不确定度尺度 $\sigma_{t_b}$（或 $\sigma_{\tau_b}$）
2）触地前速度不确定度尺度 $\sigma_{v^-}$（至少给出水平与竖直分量尺度）

工程可行的近似做法：

* 用拟合残差 RMS 估计测量噪声尺度；
* 用线性最小二乘的参数协方差近似（对每轴独立求 $(X^\top W X)^{-1}$），再通过 $\tau_b$ 的误差传播得到 $(\sigma_{t_b},\sigma_{v^-})$。

若你暂时不想做误差传播，最低限度也应输出“残差 RMS”作为后续权重矩阵 $R$ 的尺度依据，避免权重设置拍脑袋。

### B.9 失败与降级策略（必写进接口行为）

以下情况返回 `invalid` 或 `low_confidence` 标志，供上层扩大走廊或等待更多点：

* 二次方程无实根或 $\tau_b$ 不为合理正值
* 窗口内有效点数不足（剔除后 < 最小阈值）
* 残差超阈（明显离群/丢帧/误检）
* $v_n^-$ 过小（几乎擦地滑行），反弹事件不可稳定估计
